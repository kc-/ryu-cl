(defpackage :ryu-cl (:use :common-lisp)
            (:export #:float-to-string))

(in-package :ryu-cl)

(defmethod float-to-string (float-number)
  (multiple-value-bind (significand exponent sign)
      (integer-decode-float float-number)
    (cond
      ((= 0 float-number)
       (return-from float-to-string "0.0"))
      ((or (and (typep float-number 'single-float)
                (= exponent #xFF))
           (= exponent #x7FF))
       (return-from float-to-string (if (zerop significand)
                                        "Infinity"
                                        "NaN"))))
    (let* ((e2 (- exponent 2))
           (u (* (- (* 4 significand) 2)))
           (v significand)
           (w (* (+ (* 4 significand) 2)))
           (e10 (if (minusp e2) e2 0))
           (decimal-factor (if (minusp e2) (expt 5 (- e2)) (expt 2 e2))))
      (multiple-value-bind (dec-coeff dec-exponent)
          (compute-shortest (* decimal-factor u) (* decimal-factor v) (* decimal-factor w))
        (let* ((digits (princ-to-string dec-coeff))
               (final-exponent (1- (+ dec-exponent e10 (length digits)))))
          (with-output-to-string (s)
            (cond
              ((< -4 final-exponent 7)
               (cond ((plusp final-exponent)
                      (princ (subseq digits 0 (min (length digits) (1+ final-exponent))) s)
                      (let ((n-zeros (1+ (- final-exponent (length digits)))))
                        (when (plusp n-zeros)
                          (princ (subseq "000" 0 n-zeros) s)))
                      (princ #\. s)
                      (if (> (length digits) (1+ final-exponent))
                          (princ (subseq digits (1+ final-exponent)) s)
                          (princ "0" s)))
                     ((minusp final-exponent)
                      (princ (subseq "0.00" 0 (1+ (abs final-exponent))) s)
                      (princ digits s))
                     (T (princ digits s)
                        (princ ".0" s))))
              (T
               (when (minusp sign) (princ #\- s))
               (princ (elt digits 0) s)
               (princ #\. s)
               (princ (subseq digits 1) s)
               (princ (if (typep float-number 'single-float) #\e #\d) s)
               (princ (1- (+ dec-exponent e10 (length digits))) s)))
            s))))))

(defun compute-shortest (a b c &optional (accept-smaller T) (accept-larger T) (break-tie-down nil))
  "For a float value in the interval [A,C], compute the shortest decimal representation."
  (let ((a a) (b b) (c (if accept-larger c (1- c)))
        (digit 0)
        (all-b-zero T)
        (i 0)
        (all-a-zero T))
    (loop
       for a-floor = (floor a 10)
       for c-floor = (floor c 10)
       while (< a-floor c-floor)
       do
         (setf all-a-zero (and all-a-zero (zerop (mod a 10))))
         (setf a a-floor)
         (setf c c-floor)
         (setf digit (mod b 10))
         (setf all-b-zero (and all-b-zero (zerop digit)))
         (incf i))
    (when (and accept-smaller all-a-zero)
      (loop
         while (zerop (mod a 10))
         do
           (setf a (/ a 10))
           (setf c (truncate c 10))
           (incf i)))
    (let* ((is-tie (and all-b-zero (= 5 digit)))
           (want-round-down (or (< digit 5)
                                (and is-tie break-tie-down)))
           (round-down (or (and want-round-down (or (not (= a b))
                                                    all-a-zero))
                           (> (1+ b) c))))

      (values (if round-down c (1+ c)) i))))
